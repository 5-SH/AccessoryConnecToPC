/*     * Copyright (c) 2014 Samsung Electronics Co., Ltd.    * All rights reserved.    *    * Redistribution and use in source and binary forms, with or without    * modification, are permitted provided that the following conditions are    * met:    *    *     * Redistributions of source code must retain the above copyright    *        notice, this list of conditions and the following disclaimer.   *     * Redistributions in binary form must reproduce the above   *       copyright notice, this list of conditions and the following disclaimer   *       in the documentation and/or other materials provided with the   *       distribution.   *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its   *       contributors may be used to endorse or promote products derived from   *       this software without specific prior written permission.   *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package com.samsung.android.example.helloaccessoryprovider.service;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.util.HashMap;import java.util.Set;import java.util.UUID;import javax.security.cert.X509Certificate;import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothSocket;import android.content.Context;import android.content.Intent;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.pm.PackageManager.NameNotFoundException;import android.content.pm.Signature;import android.os.Binder;import android.os.IBinder;import android.text.format.Time;import android.util.Log;import android.widget.Toast;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.SA;import com.samsung.android.sdk.accessory.SAAgent;import com.samsung.android.sdk.accessory.SAAuthenticationToken;import com.samsung.android.sdk.accessory.SAPeerAgent;import com.samsung.android.sdk.accessory.SASocket;public class HelloAccessoryProviderService extends SAAgent {	public static final String TAG = "HelloAccessoryProviderService";	public static final String TAG_BLUETOOTH = "MyBluetooth";	BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();	public Boolean isAuthentication = false;	public Context mContext = null;	public static final int SERVICE_CONNECTION_RESULT_OK = 0;	public static final int HELLOACCESSORY_CHANNEL_ID = 104;	HashMap<Integer, HelloAccessoryProviderConnection> mConnectionsMap = null;	private final IBinder mBinder = new LocalBinder();	// private int authCount = 1;	/*	 * Handler bHandler = new Handler() {	 * 	 * @Override public void handleMessage(Message msg) {	 * 	 * // msg.what : Type을 정한다. switch (msg.what) {	 * 	 * case 1: String fetchStr = msg.obj.toString(); Log.e("QUKI_MAIN",	 * fetchStr); Toast.makeText(getBaseContext(), fetchStr, Toast.LENGTH_SHORT)	 * .show(); transferToDevice(); break; }	 * 	 * }	 * 	 * };	 */	public class LocalBinder extends Binder {		public HelloAccessoryProviderService getService() {			return HelloAccessoryProviderService.this;		}	}	public HelloAccessoryProviderService() {		super(TAG, HelloAccessoryProviderConnection.class);	}	public class HelloAccessoryProviderConnection extends SASocket {		private int mConnectionId;		public HelloAccessoryProviderConnection() {			super(HelloAccessoryProviderConnection.class.getName());		}		@Override		public void onError(int channelId, String errorString, int error) {			Log.e(TAG, "Connection is not alive ERROR: " + errorString + "  "					+ error);		}		@Override		public void onReceive(int channelId, byte[] data) {			Log.d(TAG, "onReceive");			final HelloAccessoryProviderConnection uHandler = mConnectionsMap					.get(Integer.parseInt(String.valueOf(mConnectionId)));			final String message = "Hello Gear";			final String fromGearMessage = new String(data); 			Log.e("QUKI", fromGearMessage);			transferToDevice();						if (uHandler == null) {				Log.e(TAG,						"Error, can not get HelloAccessoryProviderConnection handler");				return;			}						new Thread(new Runnable() {				public void run() {						try {							uHandler.send(HELLOACCESSORY_CHANNEL_ID,									message.getBytes());						} catch (IOException e) {							e.printStackTrace();						}				}			}).start();		}		@Override		protected void onServiceConnectionLost(int errorCode) {			Log.e(TAG, "onServiceConectionLost  for peer = " + mConnectionId					+ "error code =" + errorCode);			if (mConnectionsMap != null) {				mConnectionsMap.remove(mConnectionId);			}		}	}	@Override	public void onCreate() {		super.onCreate();		Toast.makeText(getApplicationContext(), "onCreate", Toast.LENGTH_SHORT)				.show();		Log.i(TAG, "onCreate of smart view Provider Service");		SA mAccessory = new SA();		try {			mAccessory.initialize(this);		} catch (SsdkUnsupportedException e) {			// Error Handling		} catch (Exception e1) {			Log.e(TAG, "Cannot initialize Accessory package.");			e1.printStackTrace();			/*			 * Your application can not use Accessory package of Samsung Mobile			 * SDK. You application should work smoothly without using this SDK,			 * or you may want to notify user and close your app gracefully			 * (release resources, stop Service threads, close UI thread, etc.)			 */			stopSelf();		}		if (mBluetoothAdapter.isEnabled()) {			Log.e(TAG_BLUETOOTH, "mBluetoothAdapter is enabled");			// get the paired devices			Set<BluetoothDevice> pairedDevices = mBluetoothAdapter					.getBondedDevices();			for (BluetoothDevice pairedDevice : pairedDevices) {				Log.e(TAG_BLUETOOTH, pairedDevice.getName());			}			//transferToDevice();		}		else {			Log.e(TAG_BLUETOOTH, "mBluetoothAdapter is NOT enabled");		}	}	@Override	protected void onServiceConnectionRequested(SAPeerAgent peerAgent) {		/*		 * The authenticatePeerAgent(peerAgent) API may not be working properly		 * depending on the firmware version of accessory device. Recommend to		 * upgrade accessory device firmware if possible.		 */		// if(authCount%2 == 1)		// isAuthentication = false;		// else		// isAuthentication = true;		// authCount++;		isAuthentication = false;		if (isAuthentication) {			Toast.makeText(getBaseContext(), "Authentication On!",					Toast.LENGTH_SHORT).show();			Log.e(TAG, "Start authenticatePeerAgent");			authenticatePeerAgent(peerAgent);		} else {			Toast.makeText(getBaseContext(), "Authentication Off!",					Toast.LENGTH_SHORT).show();			Log.e(TAG, "acceptServiceConnectionRequest");			acceptServiceConnectionRequest(peerAgent);		}	}	protected void onAuthenticationResponse(SAPeerAgent uPeerAgent,			SAAuthenticationToken authToken, int error) {		if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_CERTIFICATE_X509) {			mContext = getApplicationContext();			byte[] myAppKey = getApplicationCertificate(mContext);			if (authToken.getKey() != null) {				boolean matched = true;				if (authToken.getKey().length != myAppKey.length) {					matched = false;				} else {					for (int i = 0; i < authToken.getKey().length; i++) {						if (authToken.getKey()[i] != myAppKey[i]) {							matched = false;						}					}				}				if (matched) {					acceptServiceConnectionRequest(uPeerAgent);					Log.e(TAG, "Auth-certification matched");				} else					Log.e(TAG, "Auth-certification not matched");			}		} else if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_NONE)			Log.e(TAG, "onAuthenticationResponse : CERT_TYPE(NONE)");	}	private static byte[] getApplicationCertificate(Context context) {		if (context == null) {			Log.e(TAG, "getApplicationCertificate ERROR, context input null");			return null;		}		Signature[] sigs;		byte[] certificat = null;		String packageName = context.getPackageName();		if (context != null) {			try {				PackageInfo pkgInfo = null;				pkgInfo = context.getPackageManager().getPackageInfo(						packageName, PackageManager.GET_SIGNATURES);				if (pkgInfo == null) {					Log.e(TAG, "PackageInfo was null!");					return null;				}				sigs = pkgInfo.signatures;				if (sigs == null) {					Log.e(TAG, "Signature obtained was null!");				} else {					CertificateFactory cf = CertificateFactory							.getInstance("X.509");					ByteArrayInputStream stream = new ByteArrayInputStream(							sigs[0].toByteArray());					X509Certificate cert;					cert = X509Certificate.getInstance(stream);					certificat = cert.getPublicKey().getEncoded();				}			} catch (NameNotFoundException e) {				// TODO Auto-generated catch block				e.printStackTrace();			} catch (CertificateException e) {				// TODO Auto-generated catch block				e.printStackTrace();			} catch (javax.security.cert.CertificateException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}		return certificat;	}	@Override	protected void onFindPeerAgentResponse(SAPeerAgent arg0, int arg1) {		// TODO Auto-generated method stub		Log.d(TAG, "onFindPeerAgentResponse  arg1 =" + arg1);	}	@Override	protected void onServiceConnectionResponse(SASocket thisConnection,			int result) {		if (result == CONNECTION_SUCCESS) {			if (thisConnection != null) {				HelloAccessoryProviderConnection myConnection = (HelloAccessoryProviderConnection) thisConnection;				if (mConnectionsMap == null) {					mConnectionsMap = new HashMap<Integer, HelloAccessoryProviderConnection>();				}				myConnection.mConnectionId = (int) (System.currentTimeMillis() & 255);				Log.d(TAG, "onServiceConnection connectionID = "						+ myConnection.mConnectionId);				mConnectionsMap.put(myConnection.mConnectionId, myConnection);				Log.e(TAG, "Connection Success");			} else {				Log.e(TAG, "SASocket object is null");			}		} else if (result == CONNECTION_ALREADY_EXIST) {			Log.e(TAG, "onServiceConnectionResponse, CONNECTION_ALREADY_EXIST");		} else {			Log.e(TAG, "onServiceConnectionResponse result error =" + result);		}	}	@Override	public IBinder onBind(Intent arg0) {		return mBinder;	}	private void transferToDevice() {		// UUID 설정 (SPP)		UUID SPP_UUID = java.util.UUID				.fromString("00001101-0000-1000-8000-00805F9B34FB");		String deviceName = "QUKI";		/*		 * 클릭해서 가져온 Device의 String 값과 페어링 된 것이 일치하는지 한번 더 확인 후 BluetoothDevice		 * 객체로 target저장		 */		BluetoothDevice targetDevice = null;		Set<BluetoothDevice> pairedDevices = mBluetoothAdapter				.getBondedDevices();		for (BluetoothDevice pairedDevice : pairedDevices) {			if (pairedDevice.getName().equals(deviceName)) {				targetDevice = pairedDevice;				Log.e(TAG_BLUETOOTH, targetDevice.toString());				break;			}		}		// If the device was not found, toast an error and return		if (targetDevice == null) {			// Toast.makeText(getApplicationContext(),			// "Cannot find any devices", Toast.LENGTH_SHORT).show();			return;		}		// Create a connection to the device with the SPP UUID		BluetoothSocket mBluetoothSocket = null;		try {			mBluetoothSocket = targetDevice					.createRfcommSocketToServiceRecord(SPP_UUID);		} catch (IOException e) {			// Toast.makeText(this,			// "Unable to open a serial socket with the device",			// Toast.LENGTH_SHORT).show();			e.printStackTrace();			return;		}		// Connect to the device		try {			mBluetoothSocket.connect();		} catch (IOException e) {			// Toast.makeText(this, "Unable to connect with the device",			// Toast.LENGTH_SHORT).show();			Log.e(TAG_BLUETOOTH, "Unable to connect with the device");			e.printStackTrace();			return;		}		// Write the data by using OutputStreamWriter		try {			OutputStreamWriter outputStreamWriter = new OutputStreamWriter(					mBluetoothSocket.getOutputStream());			outputStreamWriter.write("hello");			outputStreamWriter.flush();			Log.e(TAG_BLUETOOTH, "--------------Write--------------");		} catch (IOException e) {			// Toast.makeText(this, "Unable to send message to the device",			// Toast.LENGTH_SHORT).show();			Log.e(TAG_BLUETOOTH,					"--------------Unable to send message to the device--------------");			e.printStackTrace();		}		try {			mBluetoothSocket.close();			Log.e(TAG_BLUETOOTH, "--------------Close--------------");		} catch (IOException e) {			// Toast.makeText(this, "Fail to close the connection to device",			// Toast.LENGTH_SHORT).show();			e.printStackTrace();		}	}}